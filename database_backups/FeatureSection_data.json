[{"model": "xb_promo.featuresection", "pk": 1, "fields": {"title": "General Introduction", "section_number": 1, "feature_page": 1, "article": "<p>The XBasic application package provides a PDE for writing program code in the XBasic Programming Language and for designing Graphical User Interfaces (GUI) for the programs written. These programs can be for either Linux or Windows environments.</p>\r\n<p>The code is 32-bit compatible, so it will run on 32 or 64-bit computers. A 64-bit only version is also now available for Linux environments. Currently support for Windows up to version 10 is available, windows 11 code is available now on github (see the link below).<br></p>\r\n<p>The XBasic program files are text files with a .x extension. In the PDE, these are compiled line by line into machine code in memory, when the user selects Run/Recompile. Syntax errors are reported to the user at this stage. When the user selects Run/Start the code in memory is executed, with run-time errors reported at this stage. This provides the write, test, debug cycle in the PDE.</p>\r\n<p>XBasic is a procedural version of Basic, so the user's program code is written as a set of functions, accessible to the user via a drop-down list on the PDE. In addition, functions can be saved and loaded individually using the View menu.<br></p>\r\n<p>Once the user has a working program he can select Run/Assembler then Run/Make Standalone to create a standalone, working application.</p>\r\n<p>The language has support for file handling and the programmer can also opt to import C library code, or other XBasic library code, such as database libraries like SQLite. The programmer can also create library files for use with other XBasic applications.<br>", "excerpt": "", "section_image": "image/upload/v1680705009/wv7junzjpke1jo6wjiwm.webp"}}, {"model": "xb_promo.featuresection", "pk": 4, "fields": {"title": "Gui-Design Toolkit", "section_number": 1, "feature_page": 2, "article": "<p>The GUI design toolkit consists of the Toolbox menu, which contains buttons to select the various different grid controls, buttons, lists etc, the Window object, on which the grids are to be drawn and the Grid definition toolbox which allows for the selection of colour, justification etc. for the selected grid in the window.</p><p>This makes for a very direct and straight-forward, interactive way to design user interfaces for the application program.</p><p>Once the window has been defined in this way, it can be saved to the application program as a function.<br>", "excerpt": "", "section_image": "image/upload/v1680876925/cz7kqicg4tyto4dajqma.webp"}}, {"model": "xb_promo.featuresection", "pk": 2, "fields": {"title": "GUI-Design Code", "section_number": 2, "feature_page": 2, "article": "<p>Once the GUI window has been designed and saved as a function, two functions are produced: WindowName() and WindowNameCode(). Function WindowName() defines the layout and function WindowNameCode() is used to define the actions arising from child elements (kids) of the window.</p><p>As can be seen from the image on the left, the WindowCode() function includes, by default, a selection block which determines the action (if any) to be taken when a grid is selected. These can either call separate functions, or subroutines within the function. In the example in the image, the SUBMIT button may well invoke a ValidateAndSave subroutine, for example.</p><p>In addition to the features specified for each grid on the window, other decorators, such as hint strings for hover text can be defined in the Window() Function.<br>", "excerpt": "", "section_image": "image/upload/v1680806869/go5fyphihyslljcfaiml.webp"}}, {"model": "xb_promo.featuresection", "pk": 3, "fields": {"title": "Data Types", "section_number": 1, "feature_page": 3, "article": "<p>XBasic as a programming language is a further development from BASIC. Like this, it is strongly data-typed, with allowance for 8, 16, 32 and 64 bit signed and unsigned data types.</p><p>As shown in the image, data types can be explicitly declared with the type name or implicitly declared with the name of the variable being suffixed by @, %, #, !, $ etc. as explained in more detail in the documentation.</p><p>Literal data types include \"string\", decimal: 0.456, integer: 1234, exponent: 1.5E4, hexadecimal: 0x5a and binary 0b0110110.</p><p>Arrays var[ ] of these types as well as user-defined types consisting of these and other user-defined types can also be created.<br></p><p>Data types are well supported by type conversion functions and more explicit type conversions are supported in the library code available on GitHub as well as dynamic JSON data objects.<br></p><p>Example programs are included in the download and the help menu provides a comprehensive list of language features and functions", "excerpt": "", "section_image": "image/upload/v1680872529/gopkc2yqvndabnbusy5g.webp"}}, {"model": "xb_promo.featuresection", "pk": 5, "fields": {"title": "Program Structure", "section_number": 2, "feature_page": 3, "article": "<p>XBasic is a procedure-based language, with the application code divided into functions. Every program begins user execution at the Entry() function. New functions are added in the PDE using the View menu option, the declarations are then added automatically to the PROLOG.<br></p><p>The start of the application program is the PROLOG which is used to define user data types, imported libraries, function declarations, program constants and shared variables.</p><p>Variables declared within functions are local to the function, with shared variables being declared explicitly in the function. In addition to these data scope rules, variables can be designated as shared for use by other functions by prefixing them with&nbsp; #, ie: #mySharedVar. This feature is particularly useful for setting-up program-wide variables in initialisation functions.<br>", "excerpt": "", "section_image": "image/upload/v1680882774/twuha9yxawod27s58o6h.webp"}}, {"model": "xb_promo.featuresection", "pk": 6, "fields": {"title": "XBasic Built-in Functions", "section_number": 1, "feature_page": 4, "article": "<p>XBasic has many built-in functions. Those that form part of the language are typed in CAPITAL letters. As well the examples in the image, these include string handling such RIGHT$(), MID$(), LEFT$() and numeric functions such as INT(), ABS() and file-handling functions such as OPEN() and READ().</p><p>An index of these functions is available in the Help menu of the PDE. Also listed in the help index are additional functions available in the Xst library, such XstClearConsole() imported in the PROLOG.</p><p>Further functions can be incorporated from C and other XBasic libraries compiled and imported into the XBasic Program.<br>", "excerpt": "", "section_image": "image/upload/v1680891067/os5hszfaqxcfhlseoon8.webp"}}, {"model": "xb_promo.featuresection", "pk": 7, "fields": {"title": "Compile-Time Errors", "section_number": 1, "feature_page": 5, "article": "<p>The XBasic PDE provides very useful compile-time error reporting. Error reports are created when the user selects Run/Start or one of the other compile options. </p><p>As shown in the image, syntax errors, invalid variable and function name references and other typos are detected and the relevant lines of code are marked with error numbers. The system also displays an error window that enables stepping through the errors in order of detection.</p><p>Error numbering is removed automatically when the code is re-run or compiled. </p><p>To make best use of these features, the programmer should write code in small, testable chunks.<br>", "excerpt": "", "section_image": "image/upload/v1680939578/lmcsl9mgi5jxqk8qmlq3.webp"}}, {"model": "xb_promo.featuresection", "pk": 8, "fields": {"title": "Run-Time Errors", "section_number": 2, "feature_page": 5, "article": "<p>When the user's program is run, using the Run/Start option on the PDE, run-time errors are reported as soon as they are encountered, as shown in the image. Typically these errors might be Overflow for numeric operations or Array bounds crossed. The error location is indicated and the error report message generated.</p><p>It also worth noting, that the user can break-out of the running program at any time with the relevant option on the PDE toolbar. This is particularly helpful when the programmer suspects a perpetual loop, as in an uncompleted WHILE loop for example.</p><p>Furthermore debugging break-points can be included/removed in the code.<br>", "excerpt": "", "section_image": "image/upload/v1680942275/g3f1iqc3hv13adtaw149.webp"}}]